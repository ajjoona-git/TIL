## map 함수

`map(function, *iterables)`

리스트, 튜플 등 반복 가능한 객체를 입력받아, 해당 객체의 모든 요소에 대해 특정 함수를 반복적으로 수행한다.

- 어떻게 다음 값을 계산할지에 대한 ‘방법’만 알고 있을 뿐, 값이 아닌 ‘이터레이터(ierator)’를 반환한다.

### map 객체

`<map object at 0x000001F51048B970>`

map() 함수를 지연 평가한 아웃풋. 어떻게 처리할 지에 대한 계획만 하고 아직 실행하지 않은 **대기 단계.**

- '이터러블 (Iterable)': `for`문으로 하나씩 요소를 꺼낼 수 있는 객체. 리스트, 튜플, 문자열 등이 여기에 해당한다. 말 그대로 '반복 가능한' 객체이다.
- '이터레이터 (Iterator)': 값을 차례대로 꺼낼 수 있는 '흐름(stream)'을 가진 객체. `next()` 함수를 호출하여 다음 값을 생성할 수 있으며, 한 번 소비하면 다시 사용할 수 없다.
- 이터레이터가 가진 값 보기(=소비하기) → `list()`, `for`문

### 왜 이럼? ‘메모리 효율성’

Shat if 데이터가 10억 개? 시간과 메모리가 낭비된다. 

So, 결과를 달라고 요청하는 시점에 필요한 만큼만 계산한다. 

실제로 이터레이터를 이용해 for문을 실행할 때 필요한 정보를 얻었다면 남은 데이터는 평가하지 않는다.

## 지연 평가

`map, range, zip 등`

```python
# 지연 평가

# 리스트를 사용한 for문(반복) -> 모든 데이터에 대한 메모리를 만들고 시작
a = [1, 2, 3, 4, 5, ..., 100000000]

for i in a:
    pass

# range()를 사용한 for문(반복) -> range의 규칙을 저장한 이터레이터
# 그때그때 메모리를 만들고 사용이 끝난 메모리는 삭제한다.
for i in range(100000000):
    pass
```

- 기술적 흐름: `map(함수, 이터러블)` → `이터레이터` 생성 → `list()`로 `소비` → 지연되었던 계산 실행 → 결과 `리스트` 반환.