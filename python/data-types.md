# 스스로 학습

## Slicing 슬라이싱

### Slicing Cases

```python
a = "ABCDE"
print(a[1:4:1])  # "BCD" / 순방향(step=1)
print(a[1:4:-1])  # 출력 없음 / 역방향인데 시작 인덱스가 작고 끝 인덱스가 크기 때문에 출력 불가
print(a[4:1:-1])  # "EDC" / 역방향(step=-1)
print(a[4:1])  # 출력 없음 / 시작 인덱스가 크고 순방향(step=1)이기 때문에 출력 불가
print(a[1:6:])  # "BCDE" / 인덱스 범위가 문자열 크기를 넘어가는 경우 가능한 만큼만 출력
print(a[1:4:3])  # "B" / step이 인덱스 범위를 넘어가는 경우
print(a[::0])  # ValueError / step은 0이 될 수 없음
print(a[2:2])  # "" / start == stop인 경우 빈 문자열 반환
```
- step(default=1)은 0이 될 수 없다.
- step > 0일 때, start < stop
- step < 0일 때, start > stop

## 실습

### 슬라이싱 [2984. 문자열 심화_Lv3]

> password 문자열의 66번째부터 68번째까지 작성된 글자를 뒤집어서 출력한다.

| 내 답변 | GPT 답변 |
| -- | -- |
| `password[68:65:-1]` | `password[66:69][::-1]` |
| 단일 슬라이싱 + 역방향 | 슬라이싱 후 뒤집기 |
| 슬라이싱에서 **step = -1** 을 명시하여 **거꾸로 자르기**<br>시작 인덱스가 더 **큰 수**여야 하고, **종료 인덱스는 포함 안 됨** | 먼저 `password[66:69]` **정방향 슬라이싱**으로 글자 추출<br>그 결과 문자열을 `. [::-1]` 로 뒤집기 |
| 실수로 범위 잘못 잡기 쉬움<br> `[a:b:-1]`에서 `b`는 **정방향에서처럼 포함 안 됨** → 자주 혼동됨 | **직관적**이고, **버그 발생 가능성 적음** <br> 특히 `start < stop`인 경우에 안전하고 읽기 쉬움 |

### 문자열 출력 [1435. 반짝 반짝 작은별_Lv3]

> 주어진 문자열들을 적절한 변수를 할당해서 아래와 같이 출력될 수 있도록 하는 python 코드를 작성하시오.
> '반짝 반짝' / '에서도' / '작은별' / '아름답게 비치네' / '동쪽 하늘' / '서쪽 하늘'

| 내 답변 | GPT 답변 |
| -- | -- |
| `line_1 = line_twinkle + ' ' + line_star + ' ' + line_shine` <br>`line_2 = line_east + line_from + ' ' + line_west + line_from`<br>`print(line_1, line_2, line_1, sep='\n')`| `print(f"{star} {little_star} {shine}")`<br>`print(f"{east}{where} {west}{where}")`<br>`print(f"{star} {little_star} {shine}")` |
| `+` 연산자 이용한 문자열 결합 <br> `line_1`, `line_2` 활용 → 재사용 편리 | f-string 사용 → 가독성 좋음 |


<br><br>

# 수업 필기

## 프로그래밍

### 프로그램

문제를 해결하기 위한 **명령어들의 집합**

명령어 = 순서대로 주어진 지시사항들

### 프로그래밍

명령어 묶음을 만드는 과정

새 연산을 정의하고 조합해 유용한 작업을 수행하는 것

### 프로그래밍 언어

컴퓨터에게 작업을 지시하고 문제를 해결하는 도구

## Python

### 왜 python을 배우는가?

쉽고 간결한 문법, 읽고 쉽고 쓰기 쉬운 문법

세계적인 규모의 python 커뮤니티 생태계

응용 분야가 넓다 - 웹 개발, 데이터 분석, 인공지능 등

프로그래밍과 인공지능에서 기본 언어로 사용 - 광범위한 라이브러리 tensorflow, keras, pytorch 등

### 왜 인공지능과 머신러닝 개발에 python을 사용?

전문 라이브러리 - Tensorflow, pytorch, keras 등

강력한 커뮤니티와 생태계

### Python 인터프리터

Python 프로그램(우리가 작성) ↔ Python 인터프리터 ↔ 운영 체제

shell에서 명령어 하나씩 입력해서 실행 

터미널에서 `python -i` 입력하면 파이썬 인터프리터 환경이 실행, `exit()`하면 종료

- 터미널 종료
    - `X`(Hide Panel) : 창이 보이지 않게 숨기는 것. 터미널은 실행되는 중
    - `쓰레기통` (Kill Terminal) : 터미널 종료

### 표현식과 값

- 표현식: **하나의 값으로 평가**될 수 있는 모든 코드
    - 3+5, x>10, 5*4
- 평가: 표현식을 계산하여 값을 만들어 냄 (연산하는 과정?)
- 값: 표현식이 **평가된 결과**
    - 숫자, 문자열, 불리언 등

## 변수 Variable

### 변수

- 변수: 값을 다시 사용하기 위해 그 값에 붙여주는 고유한 이름(별명)
- 변수 할당: 표현식이 만들어 낸 값에 이름을 붙이는 과정
- 할당문

> degrees = 36.5
> 
> 
> `=` 할당 연산자 (오른쪽 표현식의 평가 결과 값을 왼쪽 변수에 저장)
> 

### 변수명 규칙

- 영문 알파벳, 언더스코어(_), 숫자로 구성
- 숫자로 시작할 수 없음
- 대소문자 구분
- 파이썬의 내부 예약어 사용 불가

### 메모리

- 메모리의 모든 위치에는 그 위치를 고유하게 식별하는 메모리 주소가 존재한다.
- 객체(Object) = 고유한 ID (메모리 주소) + 타입 + 값
- 변수는 특정 객체를 가리키는(refer/point to) 이름표
- **변수는 메모리 주소를 가지지(contain) 않습니다.**

### 할당문 동작 순서

1. 오른쪽 표현식 평가
2. 왼쪽 변수명 확인
    - 이미 존재하는 이름일 때 → 재할당
3. 변수명과 결과값 연결(참조)
    - 변수명이 이전에 다른 객체를 가리키고 있었다면, 그 연결은 끊어지고 새로운 객체와의 연결만 남음

### 재할당

이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것

재할당이 이루어지면, 변수는 **이전 값을 완전히 잊고 새로운 값만 기억**하게 됩니다.

# Data Types

### 타입(Type)

변수나 값이 가질 수 있는 데이터의 종류

어떤 종류의 데이터인지, **어떻게 해석되고 처리되어야 하는지를** 정의한다.

- 값(피연산자)
- 연산자

### 데이터 타입이 필요한 이유

각 타입에 따라 가능한 기능과 연산이 다르기 때문이다.

- 숫자는 더하기 가능 → 3 + 4 = 7
- 문자열은 결합 가능 → “나” + “너” = “나너”
- 숫자와 문자는 서로 더할 수 없음 → 오류 발생

## 숫자형 Numeric Types

### 정수 int

소수점이 없는 숫자. 양수, 0, 음수

### 실수 float

소수점이 있는 숫자.

### 지수 표현법

`e`나  `E`를 사용해서 지수(자리수)을 표현한다.

- 1,230,000,000 == 1.23 * 10^9 == 1.23e9
- 0.00314 == 3.14 * 10^-3 == 3.14e-3

### 산술 연산

| 기호 | 설명 |
| --- | --- |
| `//` | 몫 나눗셈 |
| `%` | 나머지 |
| `**` | 거듭제곱 |
| `-` | 음수 부호 |

### 연산자 우선순위
| 우선순위 | 연산자 | 연산 |
| --- | --- | --- |
| 높음 | `**` | 지수 |
|  | `-` | 음수 부호|
|  | `*`, `/`, `//`, `%` | 곱셈, 나눗셈, 정수 나눗셈, 나머지 |
| 낮음 | `+`, `-` | 덧셈, 뺄셈 |

**소괄호 `( )`를 적극적으로 사용하자.**

```python
-2 ** 4  # -16 / 지수의 우선순위가 더 높기 때문
-(2 ** 4)  # -16
(-2) ** 4  # 16
```

## Sequence Types

여러 개의 값들을 **순서대로 나열**하여 저장하는 자료형

### 시퀀스 타입의 공통 특징

- 순서(정렬 X), 인덱싱, 슬라이싱, 길이, 반복

### 문자열 str

문자들의 순서가 있는 변경 불가능한 시퀀스 자료형

1. 문자열 만들기
    - 작은 따옴표 또는 큰 따옴표로 감싸서 표현
        - **혼용해서 사용하지 말 것.**
        - 단, 따옴표 안에 다른 따옴표를 넣고 싶을 때는 서로 다른 종류의 따옴표를 사용한다.
            - 이스케이프 시퀀스: `\'`, `\"`, `\n` 줄바꿈, `\t` 탭, `\\` 백슬래시
        - 여러줄 또는 문자열을 작성할 때는 “”” 또는 ‘’’를 사용
2. 문자열에 값 삽입하기
    - **f-string**: 문자열 시작 전 ‘f’ 접두어를 붙이고, 삽입할 부분(표현식)을 중괄호 {}로 감싸준다
    
    ```python
    name = '홍길동'
    age = 25
    
    greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'
    
    # 안녕하세요, 제 이름은 홍길동이고 나이는 25입니다.
    print(greeting)
    ```
    

### 인덱스 (Index)

- 인덱스(Index): 각 값의 위치를 식별하기 위해 부여된 고유한 번호, **0(첫 번째 항목)부터 시작**
- 일종의 ‘거리’ 개념. ‘시작점으로부터 얼마나 떨어져 있는가’
- 음수 인덱스: 시퀀스의 끝에서부터 값에 접근할 수 있다.
    - -1은 맨 마지막 값, -2는 마지막에서 두 번째 값을 가리킨다

### 슬라이싱 (Slicing)

- 시퀀스의 일부를 잘라내어 **새로운 시퀀스를 생성한다**.

> `my_sequence[start:stop:step]`
> 
> - start: 슬라이싱을 시작할 인덱스(포함됨)
> - stop: 슬라이싱을 끝낼 인덱스 (포함되지 않음)
> - step: 몇 개씩 건너뛰며 값을 가져올지에 대한 간격

```python
my_str = 'Hello'
my_str[:3:]  # Hel
my_str[::-1]  # olleh
```

### 문자열의 불변성

- 문자열을 바꾸려면?
    
    기존 문자열의 일부와 새로운 값을 조합하여 새로운 문자열을 만들어야 함
    
- my_str = ‘Hallo’ 로 작성하면?
    
    my_str 을 변경한 것이 아니라 새로운 값으로 “재할당”한 것.
    

## 참고

### 정수형의 진법 표현

접두사를 붙여 표현

| 종류 | 접두사 | 표현 범위 |
| --- | --- | --- |
| 2진수 binary | 0b | 0과 1 |
| 8진수 octal | 0o | 0~7 |
| 16진수 hexadecimal | 0x | 0~9, a~f |

### 부동소수점(반올림) 오차

- 컴퓨터는 2진법을 사용한다.
- 10진수 소수를 2진수로 바꾸는 과정에서 무한 소수가 발생할 수 있다.
- 메모리는 유한하기 때문에 컴퓨터는 무한 소수를 가장 가까운 근사값으로 잘라서 저장한다.

⇒ decimal 모듈을 사용해 부동소수점 연산의 정확성을 보장할 수 있다.

### 문장 vs 표현식

- 문장 (statement): 특정 동작(action)을 지시하는 실행 가능한 코드의 최소 단위
- 표현식: 하나의 ‘값’으로 평가될 수 있는 모든 코드

> *이 코드를 실행하면, 그래서 ‘하나의 값’이 남나요?*
> 
> 
> ⇒ 네. 표현식 / 변수에 담을 수 있는 하나의 값으로 귀결된다.
> 
> ⇒ 아니오. 문장 / 컴퓨터에게 특정 동작을 지시하고 끝난다.
> 

### Style Guide

규칙들. 일종의 약속.
- [PEP 8](https://peps.python.org/pep-0008/)

### 주석 comment

`ctrl + /` 주석 처리/해제

### [Python tutor](https://pythontutor.com/python-compiler.html#mode=edit)

- ‘render all objects on the heap’ 옵션 선택해서 실행