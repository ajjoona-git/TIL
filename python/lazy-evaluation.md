## 지연 평가

`map, range, zip` 등 iterable 함수는 이터레이터(iterator)를 반환하며, 이터레이터는 값을 미리 생성하여 메모리에 저장하지 않고, 필요할 때마다(즉, for 루프 등에서 next() 호출을 통해) 값을 하나씩 생성하고 제공한다.

```python
# 지연 평가

# 리스트를 사용한 for문(반복) 
# -> 모든 정수 객체가 메모리에 생성되고
#    리스트 객체 내부에 그 참조들이 저장된다.
a = [1, 2, 3, 4, 5, ..., 100000000]

for i in a:
    pass

# range()를 사용한 for문(반복)
# -> range의 규칙을 저장한 이터레이터
#    그때그때 메모리를 만들고 사용이 끝난 (필요없는) 메모리는 삭제한다.
for i in range(100000000):
    pass
```

## map 함수

`map(function, *iterables)`

리스트, 튜플 등 반복 가능한 객체를 입력받아, 해당 객체의 모든 요소에 대해 특정 함수를 반복적으로 수행한다.

- 어떻게 다음 값을 계산할지에 대한 ‘방법’만 알고 있을 뿐, 값이 아닌 ‘이터레이터(ierator)’를 반환한다.

### map 객체

`<map object at 0x000001F51048B970>`

map() 함수를 지연 평가한 아웃풋. 어떻게 처리할 지에 대한 계획만 하고 아직 실행하지 않은 **대기 단계.**

- '이터러블 (Iterable)': `for`문으로 하나씩 요소를 꺼낼 수 있는 객체. 리스트, 튜플, 문자열 등이 여기에 해당한다. 말 그대로 '반복 가능한' 객체이다.

- '이터레이터 (Iterator)': 값을 차례대로 꺼낼 수 있는 '흐름(stream)'을 가진 객체. `next()` 함수를 호출하여 다음 값을 생성할 수 있으며, 한 번 소비하면 다시 사용할 수 없다.

- 이터레이터가 가진 값 보기(=소비하기) → `list()`, `for`문

## 왜 이러는 거지? ‘메모리 효율성’

What if 데이터가 10억 개? 시간과 메모리가 낭비된다. 

So, 결과를 달라고 요청하는 시점에 필요한 만큼만 계산한다. 

실제로 이터레이터를 이용해 for문을 실행할 때 필요한 정보를 얻었다면 남은 데이터는 평가하지 않는다.


### 예시

```python
name = ['김시습', '허균', '남영로', '임제', '박지원']
age = [20, 16, 52, 36, 60]
address = ['서울', '강릉', '조선', '나주', '한성부']

# map은 결과를 내지 않고 일단 덩어리로 대기 (지연 평가)
user_info_list = map(create_user, name, age, address)
print(user_info_list)  # <map object at 0x000001F51048B970>

# 필요할 때 평가를 진행 (list로 형변환 할때, 반복문을 돌릴때)
print(list(user_info_list))  # [{'김시습', 20, '서울'}, ...]
```

- 기술적 흐름: `map(함수, 이터러블)` → `이터레이터` 생성 → `list()`로 `소비` → 지연되었던 계산 실행 → 결과 `리스트` 반환.