# 스스로 학습

## [비트연산]
### 질문. `for i in range(1 << n):` 에서  `i`는 2진수의 형태(`1000000`)와 10진수 형태(`256`) 중 어떤 것을 받아오는가?

`for i in range(1 << n):`에서 `i`는 **10진수 형태의 정수**를 받아온다.

파이썬의 `range()` 함수는 항상 정수(int) 형태의 시퀀스를 생성한다. `1 << n`이라는 비트 연산의 결과 역시 정수(int)다. 예를 들어, `n=3`일 때 `1 << n`은 `1 << 3`, 즉 `8`이다. 따라서 `range(1 << n)`은 `range(8)`과 같고, `i`는 `0, 1, 2, 3, 4, 5, 6, 7`이라는 10진수 정수를 차례대로 갖게 된다.

하지만 `i`가 10진수 형태일지라도, `if i & (1 << j):`와 같은 비트 연산자를 사용하면 파이썬은 내부적으로 **두 피연산자를 2진수 형태로 변환하여 연산을 수행**한다.

<br><br>

# 코드 리뷰

## 4837. 부분집합의 합

## 내 코드

<aside>
💡

비트 연산을 이용한 부분집합 생성

- 제한시간 초과 → ‘탐색 건너뛰기’ 조건(`if len_of_subset > N or sum_of_subset > K:`) 추가
</aside>

```python
# 4837. 부분집합의 합

# import sys
# sys.stdin = open("sample_input.txt")

A = tuple(range(1, 13))  # 1부터 12까지의 숫자를 원소로 가지는 집합
T = int(input())  # 테스트 케이스의 수

for test_case in range(1, T+1):
    # 부분 집합 원소의 수 N, 부분 집합의 합 K
    N, K = map(int, input().split())
    count = 0  # 부분 집합의 수

    # N개의 원소를 택한 경우부터 탐색하기 위해 min_i, max_i를 설정 (=> 실행시간 1700ms)
    # min_i = 2 ** N - 1
    # max_i = min_i << (12 - N)
    # for i in range(min_i, max_i + 1):
    for i in range(1 << len(A)):  # (=> 실행시간 1573ms)
        sum_of_subset = 0  # 부분집합 원소의 합
        len_of_subset = 0  # 부분집합 원소의 개수
        for j in range(i):
            if i & (1 << j):
                sum_of_subset += A[j]
                len_of_subset += 1
            # 탐색 건너뛰기: N개 초과한 요소를 포함하거나, 합이 K보다 클 경우
            if len_of_subset > N or sum_of_subset > K:
                break
        # 부분집합의 원소가 N개이고 합이 K이면, count +1
        if len_of_subset == N and sum_of_subset == K:
            count += 1

    print(f'#{test_case} {count}')

```

### [Gemini] 아래 코드에서 주석처리된 1번과 2번의 실행시간이 차이나는 이유를 알려줘. 이론상으로 1번이 짧을 것 같은데 실제로는 2번이 더 짧아.

1번 코드의 의도는 이해하지만, **'탐색 범위' 자체의 비효율성** 때문에 2번 코드보다 느린 것입니다. 두 코드 모두 `break` 조건을 사용하지만, 이 조건이 얼마나 효과적으로 작동하느냐의 차이입니다.

---

### 1번 코드의 비효율적인 탐색 범위

1번 코드의 `for i in range(min_i, max_i + 1):`는 N개의 원소를 가진 부분집합(비트마스크)을 찾아내기 위한 의도였습니다. 그러나 이 범위 안에는 N개보다 많거나 적은 비트가 켜진 숫자들이 대량으로 섞여 있습니다.

예를 들어, N=3일 때 `min_i`는 `0b000000000111` (7), `max_i`는 `0b111000000000` (3584)가 됩니다. 이 범위(`7`부터 `3584`) 안에는 `0b1111` (15, 4개의 비트)이나 `0b10000` (16, 1개의 비트)와 같은, N=3 조건에 맞지 않는 숫자들이 포함되어 있습니다.

결론적으로, 1번 코드는 N개의 원소를 가진 부분집합(총 220개)을 찾기 위해 **3,578번의 불필요한 반복**을 수행합니다. 각 반복마다 안쪽 루프를 돌고 `len_of_subset == N`인지 확인해야 하므로 오버헤드가 매우 큽니다.

### 2번 코드의 효율적인 조기 종료

반면 2번 코드는 `for i in range(1 << 12):`를 통해 0부터 4095까지의 모든 경우를 순차적으로 탐색합니다. 이 방식은 언뜻 보면 더 넓은 범위를 도는 것처럼 보이지만, **조기 종료 조건(`break`)의 효과가 극대화**됩니다.

2번 코드는 `i` 값이 순차적으로 증가함에 따라, 안쪽 루프(`for j`)에서 `sum_of_subset`이나 `len_of_subset`이 `K`나 `N`을 초과하는 순간 바로 `break`가 걸리는 경우가 훨씬 많습니다. 예를 들어, `i`가 `0b1111`일 때, 세 번째 비트까지만 검사해도 `len_of_subset`이 3을 초과하므로 바로 다음 `i`로 넘어갈 수 있습니다.

**1번 코드의 탐색 범위는 이러한 순차적인 이점을 누릴 수 없습니다.** 범위 내의 숫자들은 N개의 비트 수에 따라 정렬되어 있지 않기 때문에, `break` 조건이 제대로 발동하기도 전에 불필요한 연산을 하는 경우가 많습니다.

요약하자면, 1번 코드는 **비효율적으로 넓은 범위**를 탐색하며, `break` 조건의 이점을 제대로 활용하지 못해 시간이 오래 걸립니다. 2번 코드는 전체 범위를 탐색하지만, **순차적인 탐색과 효과적인 `break` 조건** 덕분에 실제 연산량은 훨씬 적어 빠르게 실행되는 것입니다.

<br><br>

# 수업 필기

## 부분집합 (Power Set)

집합 S의 모든 원소를 **포함/미포함**해 만들 수 있는 모든 하위 집합

- 모든 부분집합을 전부 나열하는 방식: `$O(N * 2^N)$`

### 부분집합 문제 접근 방식

1. 완전검색
    
    모든 부분집합을 생성한 후에 각 부분집합의 합을 계산한다.
    
    → 집합의 원소가 N개일 때, 공집합을 포함한 부분집합의 수는 **`$2^N$`**개 (조합)
    
2. 그리디
    
    조건에 맞는 경우 주어진 집합의 부분집합을 생성하는 방법을 생각해본다.
    

### 부분집합을 생성하는 방법

1. **반복문 (중첩 loop)**
- N=3, 4일 때 직관적인 접근

```python
arr = [1, 2, 3]
bit = [0] * len(arr)

# arr[i]의 원소가 부분집합에 포함되지 않으면 bit[i] == 0
# arr[i]의 원소가 부분집합에 포함되면 bit[i] == 1

for i in range(2):  # [0, 1]
		bit[0] = i
		for j in range(2):
				bit[1] = j
				for k in range(2):
						bit[2] = k
						print(bit)
						# [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], ... , [1, 1, 1]
```

2. **재귀(Backtracking) 방식**
- 원소가 많아질 때 가장 직관적인 접근, 확장 가능

```python
def generate_subset(depth, included):
    """
    현재 원소를 "포함한다/포함하지 않는다" 두 갈래로 재귀 호출하며 부분집합을 생성한다.
    depth: 현재 확인할 원소 인덱스
    included: 각 원소가 포함됐는지(True/False)를 기록
    """
    # 모든 원소를 결정한 시점
    if depth == len(input_list):
        # included 상태에 따라 부분집합 생성
        current_subset = [
            input_list[i] for i in range(len(input_list)) if included[i]
        ]
        subsets.append(current_subset)
        return

    # (1) 현재 원소를 포함하지 않는 경우
    included[depth] = False
    generate_subset(depth + 1, included)

    # (2) 현재 원소를 포함하는 경우
    included[depth] = True
    generate_subset(depth + 1, included)
```

3. **비트마스크 (binary counting)**
- `i`의 2진수 표현을 각 원소를 포함시킬지 말지에 대한 ‘체크리스트’로 활용하는 것
- N이 최대 20~30까지면 효율적

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr) 		# n : 원소의 개수

for i in range(1 << n) : 		# 1<<n == 2**n : 부분 집합의 개수
		subset = []
		for j in range(n):		  # 각 원소에 접근하기 위한 인덱스 j
		    # i의 j 번째 비트가 1이면 True
        if i & (1 << j):
            subset.append(arr[j])
```

### [참고] 비트 연산

| 비트 연산자 | 설명 | 활용 |
| --- | --- | --- |
| `&` | 비트 AND | `i & (1<<j)` i의 j번째 비트가 1인지 아닌지를 검사 |
| `|` | 비트 OR |  |
| `<<: *= 2`  | 비트를 왼쪽으로 이동 | `1 << n: $2^n$` 원소가 n개일 경우의 모든 부분집합의 수 |
| `>>: //= 2`  | 비트를 오른쪽으로 이동 |  |
| `^` | 비트 XOR (Exclusive) |  |
| `~`  | 비트 NOT |  |