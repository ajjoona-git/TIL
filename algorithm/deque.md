# 수업 필기

## 데크 (Deque, Double-Ended Queue)

양쪽 끝에서 빠르게 데이터 추가와 삭제를 할 수 있는 컨테이너 자료형

- 리스트로 구현할 수 있다.
- `from collections import deque`

### `list`와의 결정적 차이: 성능

- `list`에서의 `pop(0)` 혹은 `insert(0)` 로 앞쪽 데이터를 처리하는 경우, 시간복잡도는 **`$O(n)$`**
    - 리스트는 맨 앞의 데이터를 제거하거나 추가하면, **뒤따르는 모든 데이터의 위치를 한 칸씩 옮겨야 합니다.** 데이터가 많아질수록 이 작업은 매우 느려집니다.
- `deque` 에서의 시간복잡도는 **`$O(1)$`**
    - `deque`는 내부적으로 양 끝의 위치 정보(포인터)를 가지고 있어, 데이터를 옮기지 않고 **포인터만 이동**시킵니다. 데이터의 양과 상관없이 항상 빠른 속도를 보장합니다.

### 주요 연산

| 연산 | 설명 | 시간 복잡도 |
| --- | --- | --- |
| **`append(x)`** | 오른쪽 끝에 `x`를 추가 | $O(1)$ |
| **`appendleft(x)`** | 왼쪽 끝에 `x`를 추가 | $O(1)$ |
| **`pop()`** | 오른쪽 끝 요소를 제거하고 반환 | $O(1)$ |
| **`popleft()`** | 왼쪽 끝 요소를 제거하고 반환. 요소가 없으면 IndexError | $O(1)$ |
| `rotate()` | 전체 요소를 효율적으로 회전 |  |


- `rotate()`

    • `n`이 **양수**이면, 오른쪽 끝의 `n`개 요소가 왼쪽 끝으로 이동합니다.
    (오른쪽으로 n칸 만큼 회전)

    • `n`이 **음수**이면, 왼쪽 끝의 `n`개 요소가 오른쪽 끝으로 이동합니다.
    (왼쪽으로 n칸 만큼 회전) 

### 적용 예시

```python
from collections import deque

# 초기 deque 생성
dq = deque([10, 20, 30])
print(f"초기 상태: {dq}")
# 초기 상태: deque([10, 20, 30])

# 1. append(): 오른쪽 끝에 40 추가
dq.append(40)
print(f"append(40) 후: {dq}")
# append(40) 후: deque([10, 20, 30, 40])

# 2. appendleft(): 왼쪽 끝에 0 추가
dq.appendleft(0)
print(f"appendleft(0) 후: {dq}")
# appendleft(0) 후: deque([0, 10, 20, 30, 40])

# 3. pop(): 오른쪽 끝 요소(40) 꺼내기
right_item = dq.pop()
print(f"pop()으로 꺼낸 값: {right_item}")
print(f"pop() 후: {dq}")
# pop()으로 꺼낸 값: 40
# pop() 후: deque([0, 10, 20, 30])

# 4. popleft(): 왼쪽 끝 요소(0) 꺼내기
left_item = dq.popleft()
print(f"popleft()로 꺼낸 값: {left_item}")
print(f"popleft() 후: {dq}")
# popleft()으로 꺼낸 값: 0
# popleft() 후: deque([10, 20, 30])
```

### 데크의 활용

- **큐(Queue) 구현**
    - `append()`와 `popleft()`를 사용하면 완벽한 FIFO 큐가 됩니다. (BFS 알고리즘의 표준)
- **스택(Stack) 구현**
    - `append()`와 `pop()`만 사용하면 LIFO 스택과 동일하게 동작합니다.


## 우선순위 큐 (Priority Queue)

우선순위를 가진 항목들을 저장하는 큐

- 우선순위가 높은 순서대로 출력한다.
- 배열을 이용하여 구현할 수 있다.
    - 원소를 삽입할 때 우선순위를 비교하여 적절한 위치에 삽입한다.
    - 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생하기 때문에 소요 시간이나 메모리가 많이 필요하다.
- 적용: 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케줄링 등