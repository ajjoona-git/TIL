# 코드 리뷰

## 내 코드

```python
# Gravity

# import sys
# sys.stdin = open("input.txt")

T = int(input())  # 테스트 케이스의 수

for test_case in range(1, T+1):
    N = int(input())  # 방의 가로길이
    boxes = list(map(int, input().split()))  # 상자의 개수

    drop = [0] * N  # 각 상자의 낙차를 저장할 리스트

    # boxes를 순회하면서
    for i in range(N):
        count = 0
        # 오른쪽 상자의 개수 중 현재 개수보다 작은 열의 길이를 센다.
        for j in range(i+1, N):
            if boxes[j] < boxes[i]:
                count += 1
        # 낙차량을 리스트에 저장한다.
        drop[i] = count

    max_drop = drop[0]  # 최대 낙차량
    # 그중 최대값을 찾는다.
    for i in range(1, N):
        if drop[i] > max_drop:
            max_drop = drop[i]

    # 결과를 출력한다.
    print(f'#{test_case} {max_drop}')
```

## 코드리뷰 피드백

낙차를 저장한 리스트를 생성한 후, 리스트의 최대값을 구함 ⇒ 최대값만 필요한거니까 리스트 만들 필요 없이, 낙차를 구한 후 바로 최대값과 비교해서 갱신해도 될 듯

## TIL

문제에서 요구하는 사항에 맞춘 코드 작성이 필요할 듯.

출력 값에 불필요한 과정이라면 생략하기.

<br><br>

# 수업 필기

## 배열 (Array)

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

메모리에서도 연속된 공간을 사용한다.

- 다수의 변수로 힘든 작업에서 활용

### 1차원 배열

- 1차원 배열 선언

```python
# 1차원 배열 선언
arr = list()
arr = []
arr = [0] * 10  # 크기가 정해진 배열
arr = [1, 2, 3]
```

`.append()` 배열의 크기가 커지면 시간이 증가한다. 배열의 크기를 정해 선언하는 것을 추천.

- 배열을 처음 만들 때 만든 공간보다 배열의 크기가 커지면, 더 큰 공간에 배열을 복사한 후 추가하기 때문
- 입력 받은 정수를 1차원 배열에 저장하는 방법

![image.png](attachment:2b32bc8b-96a0-4bd9-932e-6229b406e763:image.png)

```python
# 입력 받은 정수를 1차원 배열에 저장하는 방법
"""
첫 줄에 양수의 개수 N (5 <= N <= 1000)
다음 줄에 빈칸으로 구분된 N개의 양수 Ai (1 <= Ai <= 1000000)

입력 예시
6
2 7 5 3 1 4
"""
N = int(input())
arr = list(map(int, input().split()))
```

## 정렬 sort

2개 이상의 자료를 키(특정 기준)에 의해 작은 값부터 큰 값(오름차순), 또는 그 반대의 순서대로(내림차순) 재배열하는 알고리즘

### 버블 정렬 Bubble Sort

**인접한 두 개의 원소를 비교**하며 **자리를 계속 교환**하는 방식

교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양 같다고 해서 ‘버블 정렬’이라고 한다.

- 시간 복잡도: O(n^2) = N(for문) * N(for문)
- 과정
    1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
    2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
- 예시: `[55, 7, 78, 12, 42]` 를 오름차순으로 버블 정렬

![image.png](attachment:ef69196e-6c07-4a3b-9a57-625bca036003:image.png)

첫 번째 패스 결과: [7, 55, 12, 42, **78**]

마지막 자리인 78은 고정된다.

두 번째 패스 결과: [7, 12, 42, **55, 78**]

세 번째 패스 결과: [7, 12, **42, 55, 78**]

네 번째 패스 결과: [7, **12, 42, 55, 78**]

정렬 끝.

- 슈도코드

```python
BubbleSort(a,N)          # 정렬할 배열 a와 배열의 크기 N
	for i : N-1 -> 1       # 정렬할 구간의 끝
		for j : 0 -> i-1     # 비교할 원소 중 왼쪽 원소의 인덱스
			if a[j] > a[j+1]   # 왼쪽 원소가 더 크면
				a[j] <-> a[j+1]  # 오른쪽 원소와 교환
```

- 알고리즘

```python
def bubble_sort(a, N):
	for i in range(N-1, 0, -1):
		for j in range(0, i-1):
			if a[j] > a[j+1]:
				a[j], a[j+1] = a[j+1], a[j]
```