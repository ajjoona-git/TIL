# 수업 필기

## 패턴 매칭

### 고지식한 알고리즘 (Brute Force)

단순한 방법. 완전탐색

- 시간 복잡도: `$O(MN)$`

예시: 본문 문자열을 처음부터 끝까지 순회하면서 패턴 내의 문자들을 일일이 비교

```python
def brute_force(p, t):
		""" 
		본문 문자열 내에 패턴 문자열이 있다면 해당 인덱스를, 없다면 -1을 반환하는 함수
		- params
				p: 찾을 패턴(str), t: 본문 문자열(str)
		"""
		i = 0  # t의 인덱스
		j = 0  # p의 인덱스
		
		N = len(t)  # t의 길이
		M = len(p)  # p의 길이
		
		while j < M and i < N:
				# 다른 글자인 경우
				if t[i] != p[j]:
						# 불일치 시, 비교 시작 위치를 한 칸씩 앞으로 이동
            # (i - j): 패턴을 처음부터 다시 비교해야 하므로
            i = i - j
            # j를 -1로 만들고, 바로 아래서 j += 1 → j=0
            j = -1
				i += 1
				j += 1
		
		# # while 문을 빠져나온 상태에서, j가 M과 같다면 패턴을 모두 일치시킨 것
		if j == M:
				return i - M  
				
		# 검색 실패
		else:
				return -1  
```

### KMP 알고리즘

패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산한다.

불일치가 발생했을 겨웅 이동할 다음 위치를 계산하는 전처리가 필요하다.

- 패턴의 접두사/접미사가 일치하는 최대 길이를 담은 **LPS 배열**을 사용
- 불일치 시, 패턴을 한 칸씩 밀기보다, **LPS 정보를 기반**으로 적절히 패턴 인덱스를 점프
- **시간 복잡도**: 최악의 경우 `$O(N + M)$`

### 보이어-무어 (Boyer-Moore) 알고리즘

상용 소프트웨어에서 채택하고 있는 알고리즘

실제 검색에서 매우 빠른 성능