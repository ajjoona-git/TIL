# 수업 필기

## 선택 정렬 (Selection Sort)

전체 데이터에서 **최솟값**을 찾아 **맨 앞부터 순서대로 정렬**된 위치를 확정해 나가는 정렬 방식

- 구현이 매우 간단하고 직관적이다.
- 교환의 횟수가 버블 정렬, 삽입 정렬보다 작다.
- 데이터가 이미 정렬되어 있어도, 매번 최소값을 찾기 위해 전체를 비교하므로 비효율적이다.
- 시간 복잡도: **`$O(n^2)$`**
    - 파이썬의 내장 함수인 `.sort()`나 `sorted()`를 사용하는 것이 훨씬 효율적

- 정렬될 위치 (`i`)를 지정하고, 아직 정렬되지 않은 부분(`i+1`부터 끝까지)을 순회하면서 최소값을 찾아 `i`과 교환한다.

```python
def selection_sort(arr):
    # 1. 미정렬 구간 설정
    # 0부터 n-2까지, 각 자리에 들어갈 값을 찾기 위해 반복 (마지막 인덱스 전까지만 순회)
    for i in range(len(arr) - 1):
        # 2. 현재 자리를 최솟값의 위치로 가정
        min_idx = i

        # 3. 현재 자리(i) 다음부터 끝까지 탐색하며 실제 최솟값 위치를 찾음
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 4. 찾은 최솟값을 현재 자리(i)로 보내고, 원래 있던 값은 최솟값 자리로 보냄
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

## 셀렉션 알고리즘

저장되어 있는 자료(리스트 등)에서 원하는 순서(예: k번째)의 원소를 찾는 알고리즘의 총칭

- 최소값, 최대값, 중간값 , k번째로 큰/작은 값 등
- 전체 데이터를 완전히 정렬하지 않고, 선택 정렬의 일부 과정을 차용하여 **k번만 반복**한다.
- k가 비교적으로 작을 때 전체 정렬을 수행하는 것보다 효율적이다.
- k가 n에 가까워질수록 `$O(n^2)$`에 근접한다. 이 경우, 일반적인 정렬 후 `arr[k-1]`을 바로 참조하거나 퀵셀렉트 등 아른 알고리즘을 고려할 수 있다.

**부분 선택 구현 예시**

```python
def select(arr, k):
	  '''
    주어진 리스트 arr에서 k번째로 작은 원소를 반환하는 함수

    동작 방식:
    1. 첫 번째 반복: i=0 (가장 작은 원소를 찾아 arr[0]과 교환)
    2. 두 번째 반복: i=1 (두 번째로 작은 원소를 찾아 arr[1]과 교환)
    ...
    k번째 반복: i=k-1 (k번째로 작은 원소를 찾아 arr[k-1]과 교환)
    결국 arr[k-1]에는 k번째로 작은 값이 오게 되므로, arr[k-1]을 반환

    시간 복잡도: O(k * n)
    - k가 전체 n에 비해 작을수록 효율적
    '''
    # k번 반복하면서, 'k번째로 작은 원소'를 앞으로 정렬한다.
    for i in range(k):
		    min_idx = i
        # i+1부터 끝까지 돌며, arr[min_idx]보다 더 작은 원소 찾으면 갱신
		    for j in range(i + 1, len(arr)):
				    if arr[min_idx] > arr[j]:
						    min_idx = j
				
        # 찾은 최소값을 i번째와 교환
				arr[i], arr[min_idx] = arr[min_idx], arr[i]
				
		# k번째로 작은 원소 = arr[k-1]
		return arr[k-1]
```